# -*- coding: utf-8 -*-
"""Contesa2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vB_YJeSVXbLnIfcAwQj3-1iewHSu_Er9
"""

import numpy as np
import matplotlib.pyplot as plt
from keras.models import Sequential
from keras.layers import Dense, Input

class LiminalityTracker:
    def __init__(self, model, data, labels):
        self.model = model
        self.data = data
        self.labels = labels
        self.liminality_scores = []

    def calculate_liminality(self, predictions):
        # Example: Liminality defined as the percentage of predictions close to the decision boundary
        threshold = 0.5
        liminality = np.mean(np.abs(predictions - threshold) < 0.1) * 100  # within 0.1 of threshold
        self.liminality_scores.append(liminality)

    def fit(self, epochs=10, batch_size=32):
        for epoch in range(epochs):
            self.model.fit(self.data, self.labels, batch_size=batch_size, verbose=0)
            predictions = self.model.predict(self.data)
            self.calculate_liminality(predictions)

    def plot_liminality(self):
        plt.plot(self.liminality_scores, label='Liminality (%)')
        plt.title('Liminality Over Epochs')
        plt.xlabel('Epochs')
        plt.ylabel('Liminality (%)')
        plt.legend()
        plt.grid()
        plt.show()

# Generate synthetic data
np.random.seed(0)
data = np.random.rand(1000, 10)
labels = (data.sum(axis=1) > 5).astype(int)  # Simple binary labels based on a threshold

# Build a simple model
model = Sequential()
model.add(Input(shape=(10,)))  # Use Input layer
model.add(Dense(10, activation='relu'))
model.add(Dense(1, activation='sigmoid'))

# Compile the model
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# Create a LiminalityTracker instance
tracker = LiminalityTracker(model, data, labels)

# Train the model and track liminality
tracker.fit(epochs=50, batch_size=32)

# Plot the results
tracker.plot_liminality()

import numpy as np
import matplotlib.pyplot as plt
from keras.models import Sequential
from keras.layers import Dense, Input

class LiminalityTracker:
    def __init__(self, model, data, labels):
        self.model = model
        self.data = data
        self.labels = labels
        self.liminality_scores = []
        self.stability_scores = []

    def calculate_liminality(self, predictions):
        threshold = 0.5
        liminality = np.mean(np.abs(predictions - threshold) < 0.1) * 100  # within 0.1 of threshold
        self.liminality_scores.append(liminality)

    def calculate_stability(self, predictions):
        stability = np.var(predictions)
        self.stability_scores.append(stability)

    def fit(self, epochs=10, batch_size=32):
        for epoch in range(epochs):
            self.model.fit(self.data, self.labels, batch_size=batch_size, verbose=0)
            predictions = self.model.predict(self.data)
            self.calculate_liminality(predictions)
            self.calculate_stability(predictions)

    def plot_metrics(self):
        fig, ax1 = plt.subplots()

        # Plot liminality
        ax1.set_xlabel('Epochs')
        ax1.set_ylabel('Liminality (%)', color='tab:blue')
        ax1.plot(self.liminality_scores, label='Liminality (%)', color='tab:blue')
        ax1.tick_params(axis='y', labelcolor='tab:blue')

        # Create a second y-axis for stability
        ax2 = ax1.twinx()
        ax2.set_ylabel('Stability (Variance)', color='tab:orange')
        ax2.plot(self.stability_scores, label='Stability (Variance)', color='tab:orange')
        ax2.tick_params(axis='y', labelcolor='tab:orange')

        plt.title('Liminality and Stability Over Epochs')
        fig.tight_layout()
        plt.grid()
        plt.show()

# Generate synthetic data
np.random.seed(0)
data = np.random.rand(1000, 10)
labels = (data.sum(axis=1) > 5).astype(int)  # Simple binary labels based on a threshold

# Build a simple model
model = Sequential()
model.add(Input(shape=(10,)))  # Use Input layer
model.add(Dense(10, activation='relu'))
model.add(Dense(1, activation='sigmoid'))

# Compile the model
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# Create a LiminalityTracker instance
tracker = LiminalityTracker(model, data, labels)

# Train the model and track liminality and stability
tracker.fit(epochs=50, batch_size=32)

# Plot the results
tracker.plot_metrics()

import numpy as np
import matplotlib.pyplot as plt
from keras.models import Sequential
from keras.layers import Dense, Input

class LiminalityTracker:
    def __init__(self, model, data, labels):
        self.model = model
        self.data = data
        self.labels = labels
        self.liminality_scores = []
        self.stability_scores = []

    def calculate_liminality(self, predictions):
        # Liminality defined as the percentage of predictions close to the decision boundary
        threshold = 0.5
        liminality = np.mean(np.abs(predictions - threshold) < 0.1) * 100
        self.liminality_scores.append(liminality)

    def calculate_stability(self, predictions):
        stability = np.var(predictions)
        self.stability_scores.append(stability)

    def fit(self, epochs=10, batch_size=32):
        for epoch in range(epochs):
            self.model.fit(self.data, self.labels, batch_size=batch_size, verbose=0)
            predictions = self.model.predict(self.data)
            self.calculate_liminality(predictions)
            self.calculate_stability(predictions)

    def plot_metrics(self):
        plt.figure(figsize=(12, 6))

        # Plot liminality
        plt.subplot(1, 2, 1)
        plt.plot(self.liminality_scores, label='Liminality (%)', color='blue')
        plt.title('Liminality Over Epochs')
        plt.xlabel('Epochs')
        plt.ylabel('Liminality (%)')
        plt.legend()
        plt.grid()

        # Plot stability
        plt.subplot(1, 2, 2)
        plt.plot(self.stability_scores, label='Stability (Variance)', color='orange')
        plt.title('Stability Over Epochs')
        plt.xlabel('Epochs')
        plt.ylabel('Stability (Variance)')
        plt.legend()
        plt.grid()

        plt.tight_layout()
        plt.show()

# Generate synthetic data with noise
np.random.seed(0)
data = np.random.rand(1000, 10) + np.random.normal(0, 0.5, (1000, 10))  # Add noise
labels = (data.sum(axis=1) > 5).astype(int)

# Build a simple, underpowered model
model = Sequential()
model.add(Input(shape=(10,)))  # Input layer
model.add(Dense(1, activation='sigmoid'))  # Only one neuron

# Compile the model with a high learning rate
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# Create a LiminalityTracker instance
tracker = LiminalityTracker(model, data, labels)

# Train the model and track liminality and stability
tracker.fit(epochs=50, batch_size=32)

# Plot the results
tracker.plot_metrics()

import numpy as np
import matplotlib.pyplot as plt
from keras.models import Sequential
from keras.layers import Dense, Input

class LiminalityTracker:
    def __init__(self, model, data, labels):
        self.model = model
        self.data = data
        self.labels = labels
        self.liminality_scores = []
        self.stability_scores = []

    def calculate_liminality(self, predictions):
        threshold = 0.5
        liminality = np.mean(np.abs(predictions - threshold) < 0.1) * 100
        self.liminality_scores.append(liminality)

    def calculate_stability(self, predictions):
        stability = np.var(predictions)
        self.stability_scores.append(stability)

    def fit(self, epochs=10, batch_size=32):
        for epoch in range(epochs):
            self.model.fit(self.data, self.labels, batch_size=batch_size, verbose=0)
            predictions = self.model.predict(self.data)
            self.calculate_liminality(predictions)
            self.calculate_stability(predictions)

    def plot_metrics(self):
        plt.figure(figsize=(12, 6))

        # Plot liminality
        plt.subplot(1, 2, 1)
        plt.plot(self.liminality_scores, label='Liminality (%)', color='blue')
        plt.title('Liminality Over Epochs')
        plt.xlabel('Epochs')
        plt.ylabel('Liminality (%)')
        plt.legend()
        plt.grid()

        # Plot stability
        plt.subplot(1, 2, 2)
        plt.plot(self.stability_scores, label='Stability (Variance)', color='orange')
        plt.title('Stability Over Epochs')
        plt.xlabel('Epochs')
        plt.ylabel('Stability (Variance)')
        plt.legend()
        plt.grid()

        plt.tight_layout()
        plt.show()

# Generate synthetic data with increased noise
np.random.seed(0)
data = np.random.rand(1000, 10) + np.random.normal(0, 1, (1000, 10))  # Add more noise
labels = (data.sum(axis=1) > 5).astype(int)

# Build a very simple model with no hidden layers
model = Sequential()
model.add(Input(shape=(10,)))  # Input layer
model.add(Dense(1, activation='sigmoid'))  # Output layer with no hidden layers

# Compile the model with a very high learning rate
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# Create a LiminalityTracker instance
tracker = LiminalityTracker(model, data, labels)

# Train the model and track liminality and stability
tracker.fit(epochs=50, batch_size=32)

# Plot the results
tracker.plot_metrics()

import numpy as np
import matplotlib.pyplot as plt
from keras.models import Sequential
from keras.layers import Dense, Input
from keras.initializers import Constant

class LiminalityTracker:
    def __init__(self, model, data, labels):
        self.model = model
        self.data = data
        self.labels = labels
        self.liminality_scores = []
        self.stability_scores = []

    def calculate_liminality(self, predictions):
        threshold = 0.5
        liminality = np.mean(np.abs(predictions - threshold) < 0.1) * 100
        self.liminality_scores.append(liminality)

    def calculate_stability(self, predictions):
        stability = np.var(predictions)
        self.stability_scores.append(stability)

    def fit(self, epochs=10, batch_size=32):
        for epoch in range(epochs):
            self.model.fit(self.data, self.labels, batch_size=batch_size, verbose=0)
            predictions = self.model.predict(self.data)
            self.calculate_liminality(predictions)
            self.calculate_stability(predictions)

    def plot_metrics(self):
        plt.figure(figsize=(12, 6))

        # Plot liminality
        plt.subplot(1, 2, 1)
        plt.plot(self.liminality_scores, label='Liminality (%)', color='blue')
        plt.title('Liminality Over Epochs')
        plt.xlabel('Epochs')
        plt.ylabel('Liminality (%)')
        plt.legend()
        plt.grid()

        # Plot stability
        plt.subplot(1, 2, 2)
        plt.plot(self.stability_scores, label='Stability (Variance)', color='orange')
        plt.title('Stability Over Epochs')
        plt.xlabel('Epochs')
        plt.ylabel('Stability (Variance)')
        plt.legend()
        plt.grid()

        plt.tight_layout()
        plt.show()

# Generate synthetic data with low noise
np.random.seed(0)
data = np.random.rand(1000, 10)  # Low noise
labels = (data.sum(axis=1) > 5).astype(int)  # Balanced binary labels

# Build a very simple model that outputs a constant value
model = Sequential()
model.add(Input(shape=(10,)))  # Input layer
model.add(Dense(1, activation='sigmoid', kernel_initializer=Constant(0.5), bias_initializer=Constant(0.5)))  # Constant output

# Compile the model
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# Create a LiminalityTracker instance
tracker = LiminalityTracker(model, data, labels)

# Train the model and track liminality and stability
tracker.fit(epochs=50, batch_size=32)

# Plot the results
tracker.plot_metrics()

